/**
 * Swiper 3.0.5
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 *
 * http://www.idangero.us/swiper/
 *
 * Copyright 2015, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 *
 * Licensed under MIT
 *
 * Released on: March 22, 2015
 */
!(function () {
  'use strict';

  function e(e) { e.fn.swiper = function (t) { let a; return e(this).each(function () { const e = new Swiper(this, t); a || (a = e); }), a; }; }window.Swiper = function (e, a) {
    function r() { return f.params.direction === 'horizontal'; } function i() { f.autoplayTimeoutId = setTimeout(() => { f.params.loop ? (f.fixLoop(), f._slideNext()) : f.isEnd ? a.autoplayStopOnLast ? f.stopAutoplay() : f._slideTo(0) : f._slideNext(); }, f.params.autoplay); } function s(e, t) { let a = h(e.target); if (!a.is(t)) if (typeof t === 'string')a = a.parents(t); else if (t.nodeType) { let r; return a.parents().each((e, a) => { a === t && (r = t); }), r ? t : void 0; } return a.length === 0 ? void 0 : a[0]; } function n(e, t) { t = t || {}; const a = window.MutationObserver || window.WebkitMutationObserver; const r = new a(((e) => { e.forEach((e) => { f.onResize(), f.emit('onObserverUpdate', f, e); }); })); r.observe(e, { attributes: typeof t.attributes === 'undefined' ? !0 : t.attributes, childList: typeof t.childList === 'undefined' ? !0 : t.childList, characterData: typeof t.characterData === 'undefined' ? !0 : t.characterData }), f.observers.push(r); } function o(e) { e.originalEvent && (e = e.originalEvent); const t = e.keyCode || e.charCode; if (!(e.shiftKey || e.altKey || e.ctrlKey || e.metaKey || document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea'))) { if (t === 37 || t === 39 || t === 38 || t === 40) { let a = !1; if (f.container.parents('.swiper-slide').length > 0 && f.container.parents('.swiper-slide-active').length === 0) return; for (let i = { left: window.pageXOffset, top: window.pageYOffset }, s = window.innerWidth, n = window.innerHeight, o = f.container.offset(), l = [[o.left, o.top], [o.left + f.width, o.top], [o.left, o.top + f.height], [o.left + f.width, o.top + f.height]], d = 0; d < l.length; d++) { const p = l[d]; p[0] >= i.left && p[0] <= i.left + s && p[1] >= i.top && p[1] <= i.top + n && (a = !0); } if (!a) return; }r() ? ((t === 37 || t === 39) && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), t === 39 && f.slideNext(), t === 37 && f.slidePrev()) : ((t === 38 || t === 40) && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), t === 40 && f.slideNext(), t === 38 && f.slidePrev()); } } function l(e) { e.originalEvent && (e = e.originalEvent); const t = f._wheelEvent; let a = 0; if (e.detail)a = -e.detail; else if (t === 'mousewheel') if (f.params.mousewheelForceToAxis) if (r()) { if (!(Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY))) return; a = e.wheelDeltaX; } else { if (!(Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX))) return; a = e.wheelDeltaY; } else a = e.wheelDelta; else if (t === 'DOMMouseScroll')a = -e.detail; else if (t === 'wheel') if (f.params.mousewheelForceToAxis) if (r()) { if (!(Math.abs(e.deltaX) > Math.abs(e.deltaY))) return; a = -e.deltaX; } else { if (!(Math.abs(e.deltaY) > Math.abs(e.deltaX))) return; a = -e.deltaY; } else a = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? -e.deltaX : -e.deltaY; if (f.params.freeMode) { let i = f.getWrapperTranslate() + a; if (i > 0 && (i = 0), i < f.maxTranslate() && (i = f.maxTranslate()), f.setWrapperTransition(0), f.setWrapperTranslate(i), f.updateProgress(), f.updateActiveIndex(), i === 0 || i === f.maxTranslate()) return; } else (new Date()).getTime() - f._lastWheelScrollTime > 60 && (a < 0 ? f.slideNext() : f.slidePrev()), f._lastWheelScrollTime = (new Date()).getTime(); return f.params.autoplay && f.stopAutoplay(), e.preventDefault ? e.preventDefault() : e.returnValue = !1, !1; } function d(e, t) { e = h(e); let a; let i; let s; a = e.attr('data-swiper-parallax') || '0', i = e.attr('data-swiper-parallax-x'), s = e.attr('data-swiper-parallax-y'), i || s ? (i = i || '0', s = s || '0') : r() ? (i = a, s = '0') : (s = a, i = '0'), i = i.indexOf('%') >= 0 ? `${parseInt(i, 10) * t}%` : `${i * t}px`, s = s.indexOf('%') >= 0 ? `${parseInt(s, 10) * t}%` : `${s * t}px`, e.transform(`translate3d(${i}, ${s},0px)`); } function p(e) { return e.indexOf('on') !== 0 && (e = e[0] !== e[0].toUpperCase() ? `on${e[0].toUpperCase()}${e.substring(1)}` : `on${e}`), e; } if (!(this instanceof Swiper)) return new Swiper(e, a); const u = {
      direction: 'horizontal',
      touchEventsTarget: 'container',
      initialSlide: 0,
      speed: 300,
      autoplay: !1,
      autoplayDisableOnInteraction: !0,
      freeMode: !1,
      freeModeMomentum: !0,
      freeModeMomentumRatio: 1,
      freeModeMomentumBounce: !0,
      freeModeMomentumBounceRatio: 1,
      setWrapperSize: !1,
      virtualTranslate: !1,
      effect: 'slide',
      coverflow: {
        rotate: 50, stretch: 0, depth: 100, modifier: 1, slideShadows: !0,
      },
      cube: {
        slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: 0.94,
      },
      fade: { crossFade: !1 },
      parallax: !1,
      scrollbar: null,
      scrollbarHide: !0,
      keyboardControl: !1,
      mousewheelControl: !1,
      mousewheelForceToAxis: !1,
      hashnav: !1,
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerColumn: 1,
      slidesPerColumnFill: 'column',
      slidesPerGroup: 1,
      centeredSlides: !1,
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: !0,
      shortSwipes: !0,
      longSwipes: !0,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: !0,
      onlyExternal: !1,
      threshold: 0,
      touchMoveStopPropagation: !0,
      pagination: null,
      paginationClickable: !1,
      paginationHide: !1,
      paginationBulletRender: null,
      resistance: !0,
      resistanceRatio: 0.85,
      nextButton: null,
      prevButton: null,
      watchSlidesProgress: !1,
      watchSlidesVisibility: !1,
      grabCursor: !1,
      preventClicks: !0,
      preventClicksPropagation: !0,
      slideToClickedSlide: !1,
      lazyLoading: !1,
      lazyLoadingInPrevNext: !1,
      lazyLoadingOnTransitionStart: !1,
      preloadImages: !0,
      updateOnImagesReady: !0,
      loop: !1,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      control: void 0,
      controlInverse: !1,
      allowSwipeToPrev: !0,
      allowSwipeToNext: !0,
      swipeHandler: null,
      noSwiping: !0,
      noSwipingClass: 'swiper-no-swiping',
      slideClass: 'swiper-slide',
      slideActiveClass: 'swiper-slide-active',
      slideVisibleClass: 'swiper-slide-visible',
      slideDuplicateClass: 'swiper-slide-duplicate',
      slideNextClass: 'swiper-slide-next',
      slidePrevClass: 'swiper-slide-prev',
      wrapperClass: 'swiper-wrapper',
      bulletClass: 'swiper-pagination-bullet',
      bulletActiveClass: 'swiper-pagination-bullet-active',
      buttonDisabledClass: 'swiper-button-disabled',
      paginationHiddenClass: 'swiper-pagination-hidden',
      observer: !1,
      observeParents: !1,
      a11y: !1,
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      runCallbacksOnInit: !0,
    }; a = a || {}; for (const c in u) if (typeof a[c] === 'undefined')a[c] = u[c]; else if (typeof a[c] === 'object') for (const m in u[c]) typeof a[c][m] === 'undefined' && (a[c][m] = u[c][m]); var f = this; f.params = a, f.classNames = []; let h; if (h = typeof t === 'undefined' ? window.Dom7 || window.Zepto || window.jQuery : t, h && (f.$ = h, f.container = h(e), f.container.length !== 0)) {
      if (f.container.length > 1) return void f.container.each(function () { new Swiper(this, a); }); f.container[0].swiper = f, f.container.data('swiper', f), f.classNames.push(`swiper-container-${f.params.direction}`), f.params.freeMode && f.classNames.push('swiper-container-free-mode'), f.support.flexbox || (f.classNames.push('swiper-container-no-flexbox'), f.params.slidesPerColumn = 1), (f.params.parallax || f.params.watchSlidesVisibility) && (f.params.watchSlidesProgress = !0), ['cube', 'coverflow'].indexOf(f.params.effect) >= 0 && (f.support.transforms3d ? (f.params.watchSlidesProgress = !0, f.classNames.push('swiper-container-3d')) : f.params.effect = 'slide'), f.params.effect !== 'slide' && f.classNames.push(`swiper-container-${f.params.effect}`), f.params.effect === 'cube' && (f.params.resistanceRatio = 0, f.params.slidesPerView = 1, f.params.slidesPerColumn = 1, f.params.slidesPerGroup = 1, f.params.centeredSlides = !1, f.params.spaceBetween = 0, f.params.virtualTranslate = !0, f.params.setWrapperSize = !1), f.params.effect === 'fade' && (f.params.slidesPerView = 1, f.params.slidesPerColumn = 1, f.params.slidesPerGroup = 1, f.params.watchSlidesProgress = !0, f.params.spaceBetween = 0, f.params.virtualTranslate = !0), f.params.grabCursor && f.support.touch && (f.params.grabCursor = !1), f.wrapper = f.container.children(`.${f.params.wrapperClass}`), f.params.pagination && (f.paginationContainer = h(f.params.pagination), f.params.paginationClickable && f.paginationContainer.addClass('swiper-pagination-clickable')), f.rtl = r() && (f.container[0].dir.toLowerCase() === 'rtl' || f.container.css('direction') === 'rtl'), f.rtl && f.classNames.push('swiper-container-rtl'), f.rtl && (f.wrongRTL = f.wrapper.css('display') === '-webkit-box'), f.params.slidesPerColumn > 1 && f.classNames.push('swiper-container-multirow'), f.device.android && f.classNames.push('swiper-container-android'), f.container.addClass(f.classNames.join(' ')), f.translate = 0, f.progress = 0, f.velocity = 0, f.lockSwipeToNext = function () { f.params.allowSwipeToNext = !1; }, f.lockSwipeToPrev = function () { f.params.allowSwipeToPrev = !1; }, f.lockSwipes = function () { f.params.allowSwipeToNext = f.params.allowSwipeToPrev = !1; }, f.unlockSwipeToNext = function () { f.params.allowSwipeToNext = !0; }, f.unlockSwipeToPrev = function () { f.params.allowSwipeToPrev = !0; }, f.unlockSwipes = function () { f.params.allowSwipeToNext = f.params.allowSwipeToPrev = !0; }, f.params.grabCursor && (f.container[0].style.cursor = 'move', f.container[0].style.cursor = '-webkit-grab', f.container[0].style.cursor = '-moz-grab', f.container[0].style.cursor = 'grab'), f.imagesToLoad = [], f.imagesLoaded = 0, f.loadImage = function (e, t, a, r) { function i() { r && r(); } let s; e.complete && a ? i() : t ? (s = new Image(), s.onload = i, s.onerror = i, s.src = t) : i(); }, f.preloadImages = function () { function e() { typeof f !== 'undefined' && f !== null && (void 0 !== f.imagesLoaded && f.imagesLoaded++, f.imagesLoaded === f.imagesToLoad.length && (f.params.updateOnImagesReady && f.update(), f.emit('onImagesReady', f))); }f.imagesToLoad = f.container.find('img'); for (let t = 0; t < f.imagesToLoad.length; t++)f.loadImage(f.imagesToLoad[t], f.imagesToLoad[t].currentSrc || f.imagesToLoad[t].getAttribute('src'), !0, e); }, f.autoplayTimeoutId = void 0, f.autoplaying = !1, f.autoplayPaused = !1, f.startAutoplay = function () { return typeof f.autoplayTimeoutId !== 'undefined' ? !1 : f.params.autoplay ? f.autoplaying ? !1 : (f.autoplaying = !0, f.emit('onAutoplayStart', f), void i()) : !1; }, f.stopAutoplay = function () { f.autoplayTimeoutId && (f.autoplayTimeoutId && clearTimeout(f.autoplayTimeoutId), f.autoplaying = !1, f.autoplayTimeoutId = void 0, f.emit('onAutoplayStop', f)); }, f.pauseAutoplay = function (e) { f.autoplayPaused || (f.autoplayTimeoutId && clearTimeout(f.autoplayTimeoutId), f.autoplayPaused = !0, e === 0 ? (f.autoplayPaused = !1, i()) : f.wrapper.transitionEnd(() => { f.autoplayPaused = !1, f.autoplaying ? i() : f.stopAutoplay(); })); }, f.minTranslate = function () { return -f.snapGrid[0]; }, f.maxTranslate = function () { return -f.snapGrid[f.snapGrid.length - 1]; }, f.updateContainerSize = function () { f.width = f.container[0].clientWidth, f.height = f.container[0].clientHeight, f.size = r() ? f.width : f.height; }, f.updateSlidesSize = function () {
        f.slides = f.wrapper.children(`.${f.params.slideClass}`), f.snapGrid = [], f.slidesGrid = [], f.slidesSizesGrid = []; let e; let t = f.params.spaceBetween; let a = 0; let i = 0; let s = 0; typeof t === 'string' && t.indexOf('%') >= 0 && (t = parseFloat(t.replace('%', '')) / 100 * f.size), f.virtualSize = -t, f.slides.css(f.rtl ? { marginLeft: '', marginTop: '' } : { marginRight: '', marginBottom: '' }); let n; f.params.slidesPerColumn > 1 && (n = Math.floor(f.slides.length / f.params.slidesPerColumn) === f.slides.length / f.params.slidesPerColumn ? f.slides.length : Math.ceil(f.slides.length / f.params.slidesPerColumn) * f.params.slidesPerColumn); let o; for (e = 0; e < f.slides.length; e++) {
          o = 0; const l = f.slides.eq(e); if (f.params.slidesPerColumn > 1) {
            var d; var p; var u; var c; const m = f.params.slidesPerColumn; f.params.slidesPerColumnFill === 'column' ? (p = Math.floor(e / m), u = e - p * m, d = p + u * n / m, l.css({
              '-webkit-box-ordinal-group': d, '-moz-box-ordinal-group': d, '-ms-flex-order': d, '-webkit-order': d, order: d,
            })) : (c = n / m, u = Math.floor(e / c), p = e - u * c), l.css({ 'margin-top': u !== 0 && f.params.spaceBetween && `${f.params.spaceBetween}px` }).attr('data-swiper-column', p).attr('data-swiper-row', u);
          }l.css('display') !== 'none' && (f.params.slidesPerView === 'auto' ? o = r() ? l.outerWidth(!0) : l.outerHeight(!0) : (o = (f.size - (f.params.slidesPerView - 1) * t) / f.params.slidesPerView, r() ? f.slides[e].style.width = `${o}px` : f.slides[e].style.height = `${o}px`), f.slides[e].swiperSlideSize = o, f.slidesSizesGrid.push(o), f.params.centeredSlides ? (a = a + o / 2 + i / 2 + t, e === 0 && (a = a - f.size / 2 - t), Math.abs(a) < 0.001 && (a = 0), s % f.params.slidesPerGroup === 0 && f.snapGrid.push(a), f.slidesGrid.push(a)) : (s % f.params.slidesPerGroup === 0 && f.snapGrid.push(a), f.slidesGrid.push(a), a = a + o + t), f.virtualSize += o + t, i = o, s++);
        }f.virtualSize = Math.max(f.virtualSize, f.size); let h; if (f.rtl && f.wrongRTL && (f.params.effect === 'slide' || f.params.effect === 'coverflow') && f.wrapper.css({ width: `${f.virtualSize + f.params.spaceBetween}px` }), (!f.support.flexbox || f.params.setWrapperSize) && f.wrapper.css(r() ? { width: `${f.virtualSize + f.params.spaceBetween}px` } : { height: `${f.virtualSize + f.params.spaceBetween}px` }), f.params.slidesPerColumn > 1 && (f.virtualSize = (o + f.params.spaceBetween) * n, f.virtualSize = Math.ceil(f.virtualSize / f.params.slidesPerColumn) - f.params.spaceBetween, f.wrapper.css({ width: `${f.virtualSize + f.params.spaceBetween}px` }), f.params.centeredSlides)) { for (h = [], e = 0; e < f.snapGrid.length; e++)f.snapGrid[e] < f.virtualSize + f.snapGrid[0] && h.push(f.snapGrid[e]); f.snapGrid = h; } if (!f.params.centeredSlides) { for (h = [], e = 0; e < f.snapGrid.length; e++)f.snapGrid[e] <= f.virtualSize - f.size && h.push(f.snapGrid[e]); f.snapGrid = h, Math.floor(f.virtualSize - f.size) > Math.floor(f.snapGrid[f.snapGrid.length - 1]) && f.snapGrid.push(f.virtualSize - f.size); }f.snapGrid.length === 0 && (f.snapGrid = [0]), f.params.spaceBetween !== 0 && f.slides.css(r() ? f.rtl ? { marginLeft: `${t}px` } : { marginRight: `${t}px` } : { marginBottom: `${t}px` }), f.params.watchSlidesProgress && f.updateSlidesOffset();
      }, f.updateSlidesOffset = function () { for (let e = 0; e < f.slides.length; e++)f.slides[e].swiperSlideOffset = r() ? f.slides[e].offsetLeft : f.slides[e].offsetTop; }, f.updateSlidesProgress = function (e) { if (typeof e === 'undefined' && (e = f.translate || 0), f.slides.length !== 0) { typeof f.slides[0].swiperSlideOffset === 'undefined' && f.updateSlidesOffset(); let t = f.params.centeredSlides ? -e + f.size / 2 : -e; f.rtl && (t = f.params.centeredSlides ? e - f.size / 2 : e); { f.container[0].getBoundingClientRect(), r() ? 'left' : 'top', r() ? 'right' : 'bottom'; }f.slides.removeClass(f.params.slideVisibleClass); for (let a = 0; a < f.slides.length; a++) { const i = f.slides[a]; const s = f.params.centeredSlides === !0 ? i.swiperSlideSize / 2 : 0; const n = (t - i.swiperSlideOffset - s) / (i.swiperSlideSize + f.params.spaceBetween); if (f.params.watchSlidesVisibility) { const o = -(t - i.swiperSlideOffset - s); const l = o + f.slidesSizesGrid[a]; const d = o >= 0 && o < f.size || l > 0 && l <= f.size || o <= 0 && l >= f.size; d && f.slides.eq(a).addClass(f.params.slideVisibleClass); }i.progress = f.rtl ? -n : n; } } }, f.updateProgress = function (e) { typeof e === 'undefined' && (e = f.translate || 0); const t = f.maxTranslate() - f.minTranslate(); t === 0 ? (f.progress = 0, f.isBeginning = f.isEnd = !0) : (f.progress = (e - f.minTranslate()) / t, f.isBeginning = f.progress <= 0, f.isEnd = f.progress >= 1), f.isBeginning && f.emit('onReachBeginning', f), f.isEnd && f.emit('onReachEnd', f), f.params.watchSlidesProgress && f.updateSlidesProgress(e), f.emit('onProgress', f, f.progress); }, f.updateActiveIndex = function () { let e; let t; let a; const r = f.rtl ? f.translate : -f.translate; for (t = 0; t < f.slidesGrid.length; t++) typeof f.slidesGrid[t + 1] !== 'undefined' ? r >= f.slidesGrid[t] && r < f.slidesGrid[t + 1] - (f.slidesGrid[t + 1] - f.slidesGrid[t]) / 2 ? e = t : r >= f.slidesGrid[t] && r < f.slidesGrid[t + 1] && (e = t + 1) : r >= f.slidesGrid[t] && (e = t); (e < 0 || typeof e === 'undefined') && (e = 0), a = Math.floor(e / f.params.slidesPerGroup), a >= f.snapGrid.length && (a = f.snapGrid.length - 1), e !== f.activeIndex && (f.snapIndex = a, f.previousIndex = f.activeIndex, f.activeIndex = e, f.updateClasses()); }, f.updateClasses = function () { f.slides.removeClass(`${f.params.slideActiveClass} ${f.params.slideNextClass} ${f.params.slidePrevClass}`); const e = f.slides.eq(f.activeIndex); if (e.addClass(f.params.slideActiveClass), e.next(`.${f.params.slideClass}`).addClass(f.params.slideNextClass), e.prev(`.${f.params.slideClass}`).addClass(f.params.slidePrevClass), f.bullets && f.bullets.length > 0) { f.bullets.removeClass(f.params.bulletActiveClass); let t; f.params.loop ? (t = Math.ceil(f.activeIndex - f.loopedSlides) / f.params.slidesPerGroup, t > f.slides.length - 1 - 2 * f.loopedSlides && (t -= f.slides.length - 2 * f.loopedSlides), t > f.bullets.length - 1 && (t -= f.bullets.length)) : t = typeof f.snapIndex !== 'undefined' ? f.snapIndex : f.activeIndex || 0, f.paginationContainer.length > 1 ? f.bullets.each(function () { h(this).index() === t && h(this).addClass(f.params.bulletActiveClass); }) : f.bullets.eq(t).addClass(f.params.bulletActiveClass); }f.params.loop || (f.params.prevButton && (f.isBeginning ? (h(f.params.prevButton).addClass(f.params.buttonDisabledClass), f.params.a11y && f.a11y && f.a11y.disable(h(f.params.prevButton))) : (h(f.params.prevButton).removeClass(f.params.buttonDisabledClass), f.params.a11y && f.a11y && f.a11y.enable(h(f.params.prevButton)))), f.params.nextButton && (f.isEnd ? (h(f.params.nextButton).addClass(f.params.buttonDisabledClass), f.params.a11y && f.a11y && f.a11y.disable(h(f.params.nextButton))) : (h(f.params.nextButton).removeClass(f.params.buttonDisabledClass), f.params.a11y && f.a11y && f.a11y.enable(h(f.params.nextButton))))); }, f.updatePagination = function () { if (f.params.pagination && f.paginationContainer && f.paginationContainer.length > 0) { for (var e = '', t = f.params.loop ? Math.ceil((f.slides.length - 2 * f.loopedSlides) / f.params.slidesPerGroup) : f.snapGrid.length, a = 0; t > a; a++)e += f.params.paginationBulletRender ? f.params.paginationBulletRender(a, f.params.bulletClass) : `<span class="${f.params.bulletClass}"></span>`; f.paginationContainer.html(e), f.bullets = f.paginationContainer.find(`.${f.params.bulletClass}`); } }, f.update = function (e) { function t() { r = Math.min(Math.max(f.translate, f.maxTranslate()), f.minTranslate()), f.setWrapperTranslate(r), f.updateActiveIndex(), f.updateClasses(); } if (f.updateContainerSize(), f.updateSlidesSize(), f.updateProgress(), f.updatePagination(), f.updateClasses(), f.params.scrollbar && f.scrollbar && f.scrollbar.set(), e) { let a; var r; f.params.freeMode ? t() : (a = f.params.slidesPerView === 'auto' && f.isEnd && !f.params.centeredSlides ? f.slideTo(f.slides.length - 1, 0, !1, !0) : f.slideTo(f.activeIndex, 0, !1, !0), a || t()); } }, f.onResize = function () { if (f.updateContainerSize(), f.updateSlidesSize(), f.updateProgress(), (f.params.slidesPerView === 'auto' || f.params.freeMode) && f.updatePagination(), f.params.scrollbar && f.scrollbar && f.scrollbar.set(), f.params.freeMode) { const e = Math.min(Math.max(f.translate, f.maxTranslate()), f.minTranslate()); f.setWrapperTranslate(e), f.updateActiveIndex(), f.updateClasses(); } else f.updateClasses(), f.params.slidesPerView === 'auto' && f.isEnd && !f.params.centeredSlides ? f.slideTo(f.slides.length - 1, 0, !1, !0) : f.slideTo(f.activeIndex, 0, !1, !0); }; let g = ['mousedown', 'mousemove', 'mouseup']; window.navigator.pointerEnabled ? g = ['pointerdown', 'pointermove', 'pointerup'] : window.navigator.msPointerEnabled && (g = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp']), f.touchEvents = { start: f.support.touch || !f.params.simulateTouch ? 'touchstart' : g[0], move: f.support.touch || !f.params.simulateTouch ? 'touchmove' : g[1], end: f.support.touch || !f.params.simulateTouch ? 'touchend' : g[2] }, (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && (f.params.touchEventsTarget === 'container' ? f.container : f.wrapper).addClass(`swiper-wp8-${f.params.direction}`), f.initEvents = function (e) {
        const t = e ? 'off' : 'on'; const r = e ? 'removeEventListener' : 'addEventListener';
        const i = f.params.touchEventsTarget === 'container' ? f.container[0] : f.wrapper[0];
        const s = f.support.touch ? i : document;
        const n = f.params.nested ? !0 : !1; f.browser.ie ? (i[r](f.touchEvents.start, f.onTouchStart, !1), s[r](f.touchEvents.move, f.onTouchMove, n), s[r](f.touchEvents.end, f.onTouchEnd, !1)) : (f.support.touch && (i[r](f.touchEvents.start, f.onTouchStart, !1), i[r](f.touchEvents.move, f.onTouchMove, n), i[r](f.touchEvents.end, f.onTouchEnd, !1)), !a.simulateTouch || f.device.ios || f.device.android || (i[r]('mousedown', f.onTouchStart, !1), s[r]('mousemove', f.onTouchMove, n), s[r]('mouseup', f.onTouchEnd, !1))), window[r]('resize', f.onResize), f.params.nextButton && (h(f.params.nextButton)[t]('click', f.onClickNext), f.params.a11y && f.a11y && h(f.params.nextButton)[t]('keydown', f.a11y.onEnterKey)), f.params.prevButton && (h(f.params.prevButton)[t]('click', f.onClickPrev), f.params.a11y && f.a11y && h(f.params.prevButton)[t]('keydown', f.a11y.onEnterKey)), f.params.pagination && f.params.paginationClickable && h(f.paginationContainer)[t]('click', `.${f.params.bulletClass}`, f.onClickIndex), (f.params.preventClicks || f.params.preventClicksPropagation) && i[r]('click', f.preventClicks, !0);
      }, f.attachEvents = function () { f.initEvents(); }, f.detachEvents = function () { f.initEvents(!0); }, f.allowClick = !0, f.preventClicks = function (e) { f.allowClick || (f.params.preventClicks && e.preventDefault(), f.params.preventClicksPropagation && (e.stopPropagation(), e.stopImmediatePropagation())); }, f.onClickNext = function (e) { e.preventDefault(), f.slideNext(); }, f.onClickPrev = function (e) { e.preventDefault(), f.slidePrev(); }, f.onClickIndex = function (e) { e.preventDefault(); let t = h(this).index() * f.params.slidesPerGroup; f.params.loop && (t += f.loopedSlides), f.slideTo(t); }, f.updateClickedSlide = function (e) { const t = s(e, `.${f.params.slideClass}`); if (!t) return f.clickedSlide = void 0, void (f.clickedIndex = void 0); if (f.clickedSlide = t, f.clickedIndex = h(t).index(), f.params.slideToClickedSlide && void 0 !== f.clickedIndex && f.clickedIndex !== f.activeIndex) { let a; let r = f.clickedIndex; if (f.params.loop) if (a = h(f.clickedSlide).attr('data-swiper-slide-index'), r > f.slides.length - f.params.slidesPerView)f.fixLoop(), r = f.wrapper.children(`.${f.params.slideClass}[data-swiper-slide-index="${a}"]`).eq(0).index(), setTimeout(() => { f.slideTo(r); }, 0); else if (r < f.params.slidesPerView - 1) { f.fixLoop(); const i = f.wrapper.children(`.${f.params.slideClass}[data-swiper-slide-index="${a}"]`); r = i.eq(i.length - 1).index(), setTimeout(() => { f.slideTo(r); }, 0); } else f.slideTo(r); else f.slideTo(r); } }; let v; let w; let y; let b; let T; let x; let S; let C; let M; const E = 'input, select, textarea, button'; let z = Date.now(); const P = []; f.animating = !1, f.touches = {
        startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0,
      }; let I; let k; if (f.onTouchStart = function (e) { if (e.originalEvent && (e = e.originalEvent), I = e.type === 'touchstart', I || !('which' in e) || e.which !== 3) { if (f.params.noSwiping && s(e, `.${f.params.noSwipingClass}`)) return void (f.allowClick = !0); if (!f.params.swipeHandler || s(e, f.params.swipeHandler)) { if (v = !0, w = !1, b = void 0, k = void 0, f.touches.startX = f.touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX, f.touches.startY = f.touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY, y = Date.now(), f.allowClick = !0, f.updateContainerSize(), f.swipeDirection = void 0, f.params.threshold > 0 && (S = !1), e.type !== 'touchstart') { let t = !0; h(e.target).is(E) && (t = !1), document.activeElement && h(document.activeElement).is(E) && document.activeElement.blur(), t && e.preventDefault(); }f.emit('onTouchStart', f, e); } } }, f.onTouchMove = function (e) { if (e.originalEvent && (e = e.originalEvent), !(I && e.type === 'mousemove' || e.preventedByNestedSwiper)) { if (f.params.onlyExternal) return w = !0, void (f.allowClick = !1); if (I && document.activeElement && e.target === document.activeElement && h(e.target).is(E)) return w = !0, void (f.allowClick = !1); if (f.emit('onTouchMove', f, e), !(e.targetTouches && e.targetTouches.length > 1)) { if (f.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX, f.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY, typeof b === 'undefined') { const t = 180 * Math.atan2(Math.abs(f.touches.currentY - f.touches.startY), Math.abs(f.touches.currentX - f.touches.startX)) / Math.PI; b = r() ? t > f.params.touchAngle : 90 - t > f.params.touchAngle; } if (b && f.emit('onTouchMoveOpposite', f, e), typeof k === 'undefined' && f.browser.ieTouch && (f.touches.currentX !== f.touches.startX || f.touches.currentY !== f.touches.startY) && (k = !0), v) { if (b) return void (v = !1); if (k || !f.browser.ieTouch) { f.allowClick = !1, f.emit('onSliderMove', f, e), e.preventDefault(), f.params.touchMoveStopPropagation && !f.params.nested && e.stopPropagation(), w || (a.loop && f.fixLoop(), x = f.getWrapperTranslate(), f.setWrapperTransition(0), f.animating && f.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd'), f.params.autoplay && f.autoplaying && (f.params.autoplayDisableOnInteraction ? f.stopAutoplay() : f.pauseAutoplay()), M = !1, f.params.grabCursor && (f.container[0].style.cursor = 'move', f.container[0].style.cursor = '-webkit-grabbing', f.container[0].style.cursor = '-moz-grabbin', f.container[0].style.cursor = 'grabbing')), w = !0; let i = f.touches.diff = r() ? f.touches.currentX - f.touches.startX : f.touches.currentY - f.touches.startY; i *= f.params.touchRatio, f.rtl && (i = -i), f.swipeDirection = i > 0 ? 'prev' : 'next', T = i + x; let s = !0; if (i > 0 && T > f.minTranslate() ? (s = !1, f.params.resistance && (T = f.minTranslate() - 1 + Math.pow(-f.minTranslate() + x + i, f.params.resistanceRatio))) : i < 0 && T < f.maxTranslate() && (s = !1, f.params.resistance && (T = f.maxTranslate() + 1 - Math.pow(f.maxTranslate() - x - i, f.params.resistanceRatio))), s && (e.preventedByNestedSwiper = !0), !f.params.allowSwipeToNext && f.swipeDirection === 'next' && x > T && (T = x), !f.params.allowSwipeToPrev && f.swipeDirection === 'prev' && T > x && (T = x), f.params.followFinger) { if (f.params.threshold > 0) { if (!(Math.abs(i) > f.params.threshold || S)) return void (T = x); if (!S) return S = !0, f.touches.startX = f.touches.currentX, f.touches.startY = f.touches.currentY, T = x, void (f.touches.diff = r() ? f.touches.currentX - f.touches.startX : f.touches.currentY - f.touches.startY); }(f.params.freeMode || f.params.watchSlidesProgress) && f.updateActiveIndex(), f.params.freeMode && (P.length === 0 && P.push({ position: f.touches[r() ? 'startX' : 'startY'], time: y }), P.push({ position: f.touches[r() ? 'currentX' : 'currentY'], time: (new Date()).getTime() })), f.updateProgress(T), f.setWrapperTranslate(T); } } } } } }, f.onTouchEnd = function (e) { if (e.originalEvent && (e = e.originalEvent), f.emit('onTouchEnd', f, e), v) { f.params.grabCursor && w && v && (f.container[0].style.cursor = 'move', f.container[0].style.cursor = '-webkit-grab', f.container[0].style.cursor = '-moz-grab', f.container[0].style.cursor = 'grab'); const t = Date.now(); const a = t - y; if (f.allowClick && (f.updateClickedSlide(e), f.emit('onTap', f, e), a < 300 && t - z > 300 && (C && clearTimeout(C), C = setTimeout(() => { f && (f.params.paginationHide && f.paginationContainer.length > 0 && !h(e.target).hasClass(f.params.bulletClass) && f.paginationContainer.toggleClass(f.params.paginationHiddenClass), f.emit('onClick', f, e)); }, 300)), a < 300 && t - z < 300 && (C && clearTimeout(C), f.emit('onDoubleTap', f, e))), z = Date.now(), setTimeout(() => { f && f.allowClick && (f.allowClick = !0); }, 0), !v || !w || !f.swipeDirection || f.touches.diff === 0 || T === x) return void (v = w = !1); v = w = !1; let r; if (r = f.params.followFinger ? f.rtl ? f.translate : -f.translate : -T, f.params.freeMode) { if (r < -f.minTranslate()) return void f.slideTo(f.activeIndex); if (r > -f.maxTranslate()) return void f.slideTo(f.slides.length - 1); if (f.params.freeModeMomentum) { if (P.length > 1) { const i = P.pop(); const s = P.pop(); const n = i.position - s.position; const o = i.time - s.time; f.velocity = n / o, f.velocity /= 2, Math.abs(f.velocity) < 0.02 && (f.velocity = 0), (o > 150 || (new Date()).getTime() - i.time > 300) && (f.velocity = 0); } else f.velocity = 0; P.length = 0; let l = 1e3 * f.params.freeModeMomentumRatio; const d = f.velocity * l; let p = f.translate + d; f.rtl && (p = -p); let u; let c = !1; const m = 20 * Math.abs(f.velocity) * f.params.freeModeMomentumBounceRatio; p < f.maxTranslate() && (f.params.freeModeMomentumBounce ? (p + f.maxTranslate() < -m && (p = f.maxTranslate() - m), u = f.maxTranslate(), c = !0, M = !0) : p = f.maxTranslate()), p > f.minTranslate() && (f.params.freeModeMomentumBounce ? (p - f.minTranslate() > m && (p = f.minTranslate() + m), u = f.minTranslate(), c = !0, M = !0) : p = f.minTranslate()), f.velocity !== 0 && (l = Math.abs(f.rtl ? (-p - f.translate) / f.velocity : (p - f.translate) / f.velocity)), f.params.freeModeMomentumBounce && c ? (f.updateProgress(u), f.setWrapperTransition(l), f.setWrapperTranslate(p), f.onTransitionStart(), f.animating = !0, f.wrapper.transitionEnd(() => { M && (f.emit('onMomentumBounce', f), f.setWrapperTransition(f.params.speed), f.setWrapperTranslate(u), f.wrapper.transitionEnd(() => { f.onTransitionEnd(); })); })) : f.velocity ? (f.updateProgress(p), f.setWrapperTransition(l), f.setWrapperTranslate(p), f.onTransitionStart(), f.animating || (f.animating = !0, f.wrapper.transitionEnd(() => { f.onTransitionEnd(); }))) : f.updateProgress(p), f.updateActiveIndex(); } return void ((!f.params.freeModeMomentum || a >= f.params.longSwipesMs) && (f.updateProgress(), f.updateActiveIndex())); } let g; let b = 0; let S = f.slidesSizesGrid[0]; for (g = 0; g < f.slidesGrid.length; g += f.params.slidesPerGroup) typeof f.slidesGrid[g + f.params.slidesPerGroup] !== 'undefined' ? r >= f.slidesGrid[g] && r < f.slidesGrid[g + f.params.slidesPerGroup] && (b = g, S = f.slidesGrid[g + f.params.slidesPerGroup] - f.slidesGrid[g]) : r >= f.slidesGrid[g] && (b = g, S = f.slidesGrid[f.slidesGrid.length - 1] - f.slidesGrid[f.slidesGrid.length - 2]); const E = (r - f.slidesGrid[b]) / S; if (a > f.params.longSwipesMs) { if (!f.params.longSwipes) return void f.slideTo(f.activeIndex); f.swipeDirection === 'next' && f.slideTo(E >= f.params.longSwipesRatio ? b + f.params.slidesPerGroup : b), f.swipeDirection === 'prev' && f.slideTo(E > 1 - f.params.longSwipesRatio ? b + f.params.slidesPerGroup : b); } else { if (!f.params.shortSwipes) return void f.slideTo(f.activeIndex); f.swipeDirection === 'next' && f.slideTo(b + f.params.slidesPerGroup), f.swipeDirection === 'prev' && f.slideTo(b); } } }, f._slideTo = function (e, t) { return f.slideTo(e, t, !0, !0); }, f.slideTo = function (e, t, a, i) { typeof a === 'undefined' && (a = !0), typeof e === 'undefined' && (e = 0), e < 0 && (e = 0), f.snapIndex = Math.floor(e / f.params.slidesPerGroup), f.snapIndex >= f.snapGrid.length && (f.snapIndex = f.snapGrid.length - 1); const s = -f.snapGrid[f.snapIndex]; f.params.autoplay && f.autoplaying && (i || !f.params.autoplayDisableOnInteraction ? f.pauseAutoplay(t) : f.stopAutoplay()), f.updateProgress(s); for (let n = 0; n < f.slidesGrid.length; n++)-s >= f.slidesGrid[n] && (e = n); if (typeof t === 'undefined' && (t = f.params.speed), f.previousIndex = f.activeIndex || 0, f.activeIndex = e, s === f.translate) return f.updateClasses(), !1; f.onTransitionStart(a); r() ? s : 0, r() ? 0 : s; return t === 0 ? (f.setWrapperTransition(0), f.setWrapperTranslate(s), f.onTransitionEnd(a)) : (f.setWrapperTransition(t), f.setWrapperTranslate(s), f.animating || (f.animating = !0, f.wrapper.transitionEnd(() => { f.onTransitionEnd(a); }))), f.updateClasses(), !0; }, f.onTransitionStart = function (e) { typeof e === 'undefined' && (e = !0), f.lazy && f.lazy.onTransitionStart(), e && (f.emit('onTransitionStart', f), f.activeIndex !== f.previousIndex && f.emit('onSlideChangeStart', f)); }, f.onTransitionEnd = function (e) { f.animating = !1, f.setWrapperTransition(0), typeof e === 'undefined' && (e = !0), f.lazy && f.lazy.onTransitionEnd(), e && (f.emit('onTransitionEnd', f), f.activeIndex !== f.previousIndex && f.emit('onSlideChangeEnd', f)), f.params.hashnav && f.hashnav && f.hashnav.setHash(); }, f.slideNext = function (e, t, a) { if (f.params.loop) { if (f.animating) return !1; f.fixLoop(); { f.container[0].clientLeft; } return f.slideTo(f.activeIndex + f.params.slidesPerGroup, t, e, a); } return f.slideTo(f.activeIndex + f.params.slidesPerGroup, t, e, a); }, f._slideNext = function (e) { return f.slideNext(!0, e, !0); }, f.slidePrev = function (e, t, a) { if (f.params.loop) { if (f.animating) return !1; f.fixLoop(); { f.container[0].clientLeft; } return f.slideTo(f.activeIndex - 1, t, e, a); } return f.slideTo(f.activeIndex - 1, t, e, a); }, f._slidePrev = function (e) { return f.slidePrev(!0, e, !0); }, f.slideReset = function (e, t) { return f.slideTo(f.activeIndex, t, e); }, f.setWrapperTransition = function (e, t) { f.wrapper.transition(e), f.params.effect !== 'slide' && f.effects[f.params.effect] && f.effects[f.params.effect].setTransition(e), f.params.parallax && f.parallax && f.parallax.setTransition(e), f.params.scrollbar && f.scrollbar && f.scrollbar.setTransition(e), f.params.control && f.controller && f.controller.setTransition(e, t), f.emit('onSetTransition', f, e); }, f.setWrapperTranslate = function (e, t, a) { let i = 0; let s = 0; const n = 0; r() ? i = f.rtl ? -e : e : s = e, f.params.virtualTranslate || f.wrapper.transform(f.support.transforms3d ? `translate3d(${i}px, ${s}px, ${n}px)` : `translate(${i}px, ${s}px)`), f.translate = r() ? i : s, t && f.updateActiveIndex(), f.params.effect !== 'slide' && f.effects[f.params.effect] && f.effects[f.params.effect].setTranslate(f.translate), f.params.parallax && f.parallax && f.parallax.setTranslate(f.translate), f.params.scrollbar && f.scrollbar && f.scrollbar.setTranslate(f.translate), f.params.control && f.controller && f.controller.setTranslate(f.translate, a), f.emit('onSetTranslate', f, f.translate); }, f.getTranslate = function (e, t) { let a; let r; let i; let s; return typeof t === 'undefined' && (t = 'x'), f.params.virtualTranslate ? f.rtl ? -f.translate : f.translate : (i = window.getComputedStyle(e, null), window.WebKitCSSMatrix ? s = new WebKitCSSMatrix(i.webkitTransform === 'none' ? '' : i.webkitTransform) : (s = i.MozTransform || i.OTransform || i.MsTransform || i.msTransform || i.transform || i.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,'), a = s.toString().split(',')), t === 'x' && (r = window.WebKitCSSMatrix ? s.m41 : parseFloat(a.length === 16 ? a[12] : a[4])), t === 'y' && (r = window.WebKitCSSMatrix ? s.m42 : parseFloat(a.length === 16 ? a[13] : a[5])), f.rtl && r && (r = -r), r || 0); }, f.getWrapperTranslate = function (e) { return typeof e === 'undefined' && (e = r() ? 'x' : 'y'), f.getTranslate(f.wrapper[0], e); }, f.observers = [], f.initObservers = function () { if (f.params.observeParents) for (let e = f.container.parents(), t = 0; t < e.length; t++)n(e[t]); n(f.container[0], { childList: !1 }), n(f.wrapper[0], { attributes: !1 }); }, f.disconnectObservers = function () { for (let e = 0; e < f.observers.length; e++)f.observers[e].disconnect(); f.observers = []; }, f.createLoop = function () {
        f.wrapper.children(`.${f.params.slideClass}.${f.params.slideDuplicateClass}`).remove();
        const e = f.wrapper.children(`.${f.params.slideClass}`); f.loopedSlides = parseInt(f.params.loopedSlides || f.params.slidesPerView, 10), f.loopedSlides += f.params.loopAdditionalSlides, f.loopedSlides > e.length && (f.loopedSlides = e.length); let t; const a = []; const r = []; for (e.each(function (t, i) { const s = h(this); t < f.loopedSlides && r.push(i), t < e.length && t >= e.length - f.loopedSlides && a.push(i), s.attr('data-swiper-slide-index', t); }), t = 0; t < r.length; t++)f.wrapper.append(h(r[t].cloneNode(!0)).addClass(f.params.slideDuplicateClass)); for (t = a.length - 1; t >= 0; t--)f.wrapper.prepend(h(a[t].cloneNode(!0)).addClass(f.params.slideDuplicateClass));
      }, f.destroyLoop = function () { f.wrapper.children(`.${f.params.slideClass}.${f.params.slideDuplicateClass}`).remove(); }, f.fixLoop = function () { let e; f.activeIndex < f.loopedSlides ? (e = f.slides.length - 3 * f.loopedSlides + f.activeIndex, e += f.loopedSlides, f.slideTo(e, 0, !1, !0)) : (f.params.slidesPerView === 'auto' && f.activeIndex >= 2 * f.loopedSlides || f.activeIndex > f.slides.length - 2 * f.params.slidesPerView) && (e = -f.slides.length + f.activeIndex + f.loopedSlides, e += f.loopedSlides, f.slideTo(e, 0, !1, !0)); }, f.appendSlide = function (e) { if (f.params.loop && f.destroyLoop(), typeof e === 'object' && e.length) for (let t = 0; t < e.length; t++)e[t] && f.wrapper.append(e[t]); else f.wrapper.append(e); f.params.loop && f.createLoop(), f.params.observer && f.support.observer || f.update(!0); }, f.prependSlide = function (e) { f.params.loop && f.destroyLoop(); let t = f.activeIndex + 1; if (typeof e === 'object' && e.length) { for (let a = 0; a < e.length; a++)e[a] && f.wrapper.prepend(e[a]); t = f.activeIndex + e.length; } else f.wrapper.prepend(e); f.params.loop && f.createLoop(), f.params.observer && f.support.observer || f.update(!0), f.slideTo(t, 0, !1); }, f.removeSlide = function (e) { f.params.loop && f.destroyLoop(); let t; let a = f.activeIndex; if (typeof e === 'object' && e.length) { for (let r = 0; r < e.length; r++)t = e[r], f.slides[t] && f.slides.eq(t).remove(), a > t && a--; a = Math.max(a, 0); } else t = e, f.slides[t] && f.slides.eq(t).remove(), a > t && a--, a = Math.max(a, 0); f.params.observer && f.support.observer || f.update(!0), f.slideTo(a, 0, !1); }, f.removeAllSlides = function () { for (var e = [], t = 0; t < f.slides.length; t++)e.push(t); f.removeSlide(e); }, f.effects = {
        fade: { setTranslate() { for (let e = 0; e < f.slides.length; e++) { const t = f.slides.eq(e); const a = t[0].swiperSlideOffset; let i = -a; f.params.virtualTranslate || (i -= f.translate); let s = 0; r() || (s = i, i = 0); const n = f.params.fade.crossFade ? Math.max(1 - Math.abs(t[0].progress), 0) : 1 + Math.min(Math.max(t[0].progress, -1), 0); t.css({ opacity: n }).transform(`translate3d(${i}px, ${s}px, 0px)`); } }, setTransition(e) { f.slides.transition(e), f.params.virtualTranslate && e !== 0 && f.slides.eq(f.activeIndex).transitionEnd(() => { for (let e = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'], t = 0; t < e.length; t++)f.wrapper.trigger(e[t]); }); } },
        cube: {
          setTranslate() {
            let e; let t = 0; f.params.cube.shadow && (r() ? (e = f.wrapper.find('.swiper-cube-shadow'), e.length === 0 && (e = h('<div class="swiper-cube-shadow"></div>'), f.wrapper.append(e)), e.css({ height: `${f.width}px` })) : (e = f.container.find('.swiper-cube-shadow'), e.length === 0 && (e = h('<div class="swiper-cube-shadow"></div>'), f.container.append(e)))); for (let a = 0; a < f.slides.length; a++) { const i = f.slides.eq(a); let s = 90 * a; let n = Math.floor(s / 360); f.rtl && (s = -s, n = Math.floor(-s / 360)); const o = Math.max(Math.min(i[0].progress, 1), -1); let l = 0; let d = 0; let p = 0; a % 4 === 0 ? (l = 4 * -n * f.size, p = 0) : (a - 1) % 4 === 0 ? (l = 0, p = 4 * -n * f.size) : (a - 2) % 4 === 0 ? (l = f.size + 4 * n * f.size, p = f.size) : (a - 3) % 4 === 0 && (l = -f.size, p = 3 * f.size + 4 * f.size * n), f.rtl && (l = -l), r() || (d = l, l = 0); const u = `rotateX(${r() ? 0 : -s}deg) rotateY(${r() ? s : 0}deg) translate3d(${l}px, ${d}px, ${p}px)`; if (o <= 1 && o > -1 && (t = 90 * a + 90 * o, f.rtl && (t = 90 * -a - 90 * o)), i.transform(u), f.params.cube.slideShadows) { let c = i.find(r() ? '.swiper-slide-shadow-left' : '.swiper-slide-shadow-top'); let m = i.find(r() ? '.swiper-slide-shadow-right' : '.swiper-slide-shadow-bottom'); c.length === 0 && (c = h(`<div class="swiper-slide-shadow-${r() ? 'left' : 'top'}"></div>`), i.append(c)), m.length === 0 && (m = h(`<div class="swiper-slide-shadow-${r() ? 'right' : 'bottom'}"></div>`), i.append(m)); { i[0].progress; }c.length && (c[0].style.opacity = -i[0].progress), m.length && (m[0].style.opacity = i[0].progress); } } if (f.wrapper.css({
              '-webkit-transform-origin': `50% 50% -${f.size / 2}px`, '-moz-transform-origin': `50% 50% -${f.size / 2}px`, '-ms-transform-origin': `50% 50% -${f.size / 2}px`, 'transform-origin': `50% 50% -${f.size / 2}px`,
            }), f.params.cube.shadow) if (r())e.transform(`translate3d(0px, ${f.width / 2 + f.params.cube.shadowOffset}px, ${-f.width / 2}px) rotateX(90deg) rotateZ(0deg) scale(${f.params.cube.shadowScale})`); else { const g = Math.abs(t) - 90 * Math.floor(Math.abs(t) / 90); const v = 1.5 - (Math.sin(2 * g * Math.PI / 360) / 2 + Math.cos(2 * g * Math.PI / 360) / 2); const w = f.params.cube.shadowScale; const y = f.params.cube.shadowScale / v; const b = f.params.cube.shadowOffset; e.transform(`scale3d(${w}, 1, ${y}) translate3d(0px, ${f.height / 2 + b}px, ${-f.height / 2 / y}px) rotateX(-90deg)`); } const T = f.isSafari || f.isUiWebView ? -f.size / 2 : 0; f.wrapper.transform(`translate3d(0px,0,${T}px) rotateX(${r() ? 0 : t}deg) rotateY(${r() ? -t : 0}deg)`);
          },
          setTransition(e) { f.slides.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e), f.params.cube.shadow && !r() && f.container.find('.swiper-cube-shadow').transition(e); },
        },
        coverflow: { setTranslate() { for (var e = f.translate, t = r() ? -e + f.width / 2 : -e + f.height / 2, a = r() ? f.params.coverflow.rotate : -f.params.coverflow.rotate, i = f.params.coverflow.depth, s = 0, n = f.slides.length; n > s; s++) { const o = f.slides.eq(s); const l = f.slidesSizesGrid[s]; const d = o[0].swiperSlideOffset; const p = (t - d - l / 2) / l * f.params.coverflow.modifier; let u = r() ? a * p : 0; let c = r() ? 0 : a * p; let m = -i * Math.abs(p); let g = r() ? 0 : f.params.coverflow.stretch * p; let v = r() ? f.params.coverflow.stretch * p : 0; Math.abs(v) < 0.001 && (v = 0), Math.abs(g) < 0.001 && (g = 0), Math.abs(m) < 0.001 && (m = 0), Math.abs(u) < 0.001 && (u = 0), Math.abs(c) < 0.001 && (c = 0); const w = `translate3d(${v}px,${g}px,${m}px)  rotateX(${c}deg) rotateY(${u}deg)`; if (o.transform(w), o[0].style.zIndex = -Math.abs(Math.round(p)) + 1, f.params.coverflow.slideShadows) { let y = o.find(r() ? '.swiper-slide-shadow-left' : '.swiper-slide-shadow-top'); let b = o.find(r() ? '.swiper-slide-shadow-right' : '.swiper-slide-shadow-bottom'); y.length === 0 && (y = h(`<div class="swiper-slide-shadow-${r() ? 'left' : 'top'}"></div>`), o.append(y)), b.length === 0 && (b = h(`<div class="swiper-slide-shadow-${r() ? 'right' : 'bottom'}"></div>`), o.append(b)), y.length && (y[0].style.opacity = p > 0 ? p : 0), b.length && (b[0].style.opacity = -p > 0 ? -p : 0); } } if (f.browser.ie) { const T = f.wrapper[0].style; T.perspectiveOrigin = `${t}px 50%`; } }, setTransition(e) { f.slides.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e); } },
      }, f.lazy = {
        initialImageLoaded: !1, loadImageInSlide(e) { if (typeof e !== 'undefined' && f.slides.length !== 0) { const t = f.slides.eq(e); const a = t.find('img.swiper-lazy:not(.swiper-lazy-loaded):not(.swiper-lazy-loading)'); a.length !== 0 && a.each(function () { const e = h(this); e.addClass('swiper-lazy-loading'); const a = e.attr('data-src'); f.loadImage(e[0], a, !1, () => { e.attr('src', a), e.removeAttr('data-src'), e.addClass('swiper-lazy-loaded').removeClass('swiper-lazy-loading'), t.find('.swiper-lazy-preloader, .preloader').remove(), f.emit('onLazyImageReady', f, t[0], e[0]); }), f.emit('onLazyImageLoad', f, t[0], e[0]); }); } }, load() { if (f.params.watchSlidesVisibility)f.wrapper.children(`.${f.params.slideVisibleClass}`).each(function () { f.lazy.loadImageInSlide(h(this).index()); }); else if (f.params.slidesPerView > 1) for (let e = f.activeIndex; e < f.activeIndex + f.params.slidesPerView; e++)f.slides[e] && f.lazy.loadImageInSlide(e); else f.lazy.loadImageInSlide(f.activeIndex); if (f.params.lazyLoadingInPrevNext) { const t = f.wrapper.children(`.${f.params.slideNextClass}`); t.length > 0 && f.lazy.loadImageInSlide(t.index()); const a = f.wrapper.children(`.${f.params.slidePrevClass}`); a.length > 0 && f.lazy.loadImageInSlide(a.index()); } }, onTransitionStart() { f.params.lazyLoading && (f.params.lazyLoadingOnTransitionStart || !f.params.lazyLoadingOnTransitionStart && !f.lazy.initialImageLoaded) && (f.lazy.initialImageLoaded = !0, f.lazy.load()); }, onTransitionEnd() { f.params.lazyLoading && !f.params.lazyLoadingOnTransitionStart && f.lazy.load(); },
      }, f.scrollbar = { set() { if (f.params.scrollbar) { const e = f.scrollbar; e.track = h(f.params.scrollbar), e.drag = e.track.find('.swiper-scrollbar-drag'), e.drag.length === 0 && (e.drag = h('<div class="swiper-scrollbar-drag"></div>'), e.track.append(e.drag)), e.drag[0].style.width = '', e.drag[0].style.height = '', e.trackSize = r() ? e.track[0].offsetWidth : e.track[0].offsetHeight, e.divider = f.size / f.virtualSize, e.moveDivider = e.divider * (e.trackSize / f.size), e.dragSize = e.trackSize * e.divider, r() ? e.drag[0].style.width = `${e.dragSize}px` : e.drag[0].style.height = `${e.dragSize}px`, e.track[0].style.display = e.divider >= 1 ? 'none' : '', f.params.scrollbarHide && (e.track[0].style.opacity = 0); } }, setTranslate() { if (f.params.scrollbar) { let e; const t = f.scrollbar; let a = (f.translate || 0, t.dragSize); e = (t.trackSize - t.dragSize) * f.progress, f.rtl && r() ? (e = -e, e > 0 ? (a = t.dragSize - e, e = 0) : -e + t.dragSize > t.trackSize && (a = t.trackSize + e)) : e < 0 ? (a = t.dragSize + e, e = 0) : e + t.dragSize > t.trackSize && (a = t.trackSize - e), r() ? (t.drag.transform(f.support.transforms3d ? `translate3d(${e}px, 0, 0)` : `translateX(${e}px)`), t.drag[0].style.width = `${a}px`) : (t.drag.transform(f.support.transforms3d ? `translate3d(0px, ${e}px, 0)` : `translateY(${e}px)`), t.drag[0].style.height = `${a}px`), f.params.scrollbarHide && (clearTimeout(t.timeout), t.track[0].style.opacity = 1, t.timeout = setTimeout(() => { t.track[0].style.opacity = 0, t.track.transition(400); }, 1e3)); } }, setTransition(e) { f.params.scrollbar && f.scrollbar.drag.transition(e); } }, f.controller = { setTranslate(e, t) { let a; let r; const i = f.params.control; if (f.isArray(i)) for (let s = 0; s < i.length; s++)i[s] !== t && i[s] instanceof Swiper && (e = i[s].rtl && i[s].params.direction === 'horizontal' ? -f.translate : f.translate, a = (i[s].maxTranslate() - i[s].minTranslate()) / (f.maxTranslate() - f.minTranslate()), r = (e - f.minTranslate()) * a + i[s].minTranslate(), f.params.controlInverse && (r = i[s].maxTranslate() - r), i[s].updateProgress(r), i[s].setWrapperTranslate(r, !1, f), i[s].updateActiveIndex()); else i instanceof Swiper && t !== i && (e = i.rtl && i.params.direction === 'horizontal' ? -f.translate : f.translate, a = (i.maxTranslate() - i.minTranslate()) / (f.maxTranslate() - f.minTranslate()), r = (e - f.minTranslate()) * a + i.minTranslate(), f.params.controlInverse && (r = i.maxTranslate() - r), i.updateProgress(r), i.setWrapperTranslate(r, !1, f), i.updateActiveIndex()); }, setTransition(e, t) { const a = f.params.control; if (f.isArray(a)) for (let r = 0; r < a.length; r++)a[r] !== t && a[r] instanceof Swiper && a[r].setWrapperTransition(e, f); else a instanceof Swiper && t !== a && a.setWrapperTransition(e, f); } }, f.hashnav = { init() { if (f.params.hashnav) { f.hashnav.initialized = !0; const e = document.location.hash.replace('#', ''); if (e) for (let t = 0, a = 0, r = f.slides.length; r > a; a++) { const i = f.slides.eq(a); const s = i.attr('data-hash'); if (s === e && !i.hasClass(f.params.slideDuplicateClass)) { const n = i.index(); f.slideTo(n, t, f.params.runCallbacksOnInit, !0); } } } }, setHash() { f.hashnav.initialized && f.params.hashnav && (document.location.hash = f.slides.eq(f.activeIndex).attr('data-hash') || ''); } }, f.disableKeyboardControl = function () { h(document).off('keydown', o); }, f.enableKeyboardControl = function () { h(document).on('keydown', o); }, f._wheelEvent = !1, f._lastWheelScrollTime = (new Date()).getTime(), f.params.mousewheelControl) { if (void 0 !== document.onmousewheel && (f._wheelEvent = 'mousewheel'), !f._wheelEvent) try { new WheelEvent('wheel'), f._wheelEvent = 'wheel'; } catch (L) {}f._wheelEvent || (f._wheelEvent = 'DOMMouseScroll'); }f.disableMousewheelControl = function () { return f._wheelEvent ? (f.container.off(f._wheelEvent, l), !0) : !1; }, f.enableMousewheelControl = function () { return f._wheelEvent ? (f.container.on(f._wheelEvent, l), !0) : !1; }, f.parallax = { setTranslate() { f.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () { d(this, f.progress); }), f.slides.each(function () { const e = h(this); e.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () { const t = Math.min(Math.max(e[0].progress, -1), 1); d(this, t); }); }); }, setTransition(e) { typeof e === 'undefined' && (e = f.params.speed), f.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () { const t = h(this); let a = parseInt(t.attr('data-swiper-parallax-duration'), 10) || e; e === 0 && (a = 0), t.transition(a); }); } }, f._plugins = []; for (const D in f.plugins) { const G = f.plugins[D](f, f.params[D]); G && f._plugins.push(G); } return f.callPlugins = function (e) { for (let t = 0; t < f._plugins.length; t++)e in f._plugins[t] && f._plugins[t][e](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]); }, f.emitterEventListeners = {}, f.emit = function (e) { f.params[e] && f.params[e](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]); let t; if (f.emitterEventListeners[e]) for (t = 0; t < f.emitterEventListeners[e].length; t++)f.emitterEventListeners[e][t](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]); f.callPlugins && f.callPlugins(e, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]); }, f.on = function (e, t) { return e = p(e), f.emitterEventListeners[e] || (f.emitterEventListeners[e] = []), f.emitterEventListeners[e].push(t), f; }, f.off = function (e, t) { let a; if (e = p(e), typeof t === 'undefined') return f.emitterEventListeners[e] = [], f; if (f.emitterEventListeners[e] && f.emitterEventListeners[e].length !== 0) { for (a = 0; a < f.emitterEventListeners[e].length; a++)f.emitterEventListeners[e][a] === t && f.emitterEventListeners[e].splice(a, 1); return f; } }, f.once = function (e, t) { e = p(e); var a = function () { t(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]), f.off(e, a); }; return f.on(e, a), f; }, f.a11y = {
        makeFocusable(e) { return e[0].tabIndex = '0', e; }, addRole(e, t) { return e.attr('role', t), e; }, addLabel(e, t) { return e.attr('aria-label', t), e; }, disable(e) { return e.attr('aria-disabled', !0), e; }, enable(e) { return e.attr('aria-disabled', !1), e; }, onEnterKey(e) { e.keyCode === 13 && (h(e.target).is(f.params.nextButton) ? (f.onClickNext(e), f.a11y.notify(f.isEnd ? f.params.lastSlideMsg : f.params.nextSlideMsg)) : h(e.target).is(f.params.prevButton) && (f.onClickPrev(e), f.a11y.notify(f.isBeginning ? f.params.firstSlideMsg : f.params.prevSlideMsg))); }, liveRegion: h('<span class="swiper-notification" aria-live="assertive" aria-atomic="true"></span>'), notify(e) { const t = f.a11y.liveRegion; t.length !== 0 && (t.html(''), t.html(e)); }, init() { if (f.params.nextButton) { const e = h(f.params.nextButton); f.a11y.makeFocusable(e), f.a11y.addRole(e, 'button'), f.a11y.addLabel(e, f.params.nextSlideMsg); } if (f.params.prevButton) { const t = h(f.params.prevButton); f.a11y.makeFocusable(t), f.a11y.addRole(t, 'button'), f.a11y.addLabel(t, f.params.prevSlideMsg); }h(f.container).append(f.a11y.liveRegion); }, destroy() { f.a11y.liveRegion && f.a11y.liveRegion.length > 0 && f.a11y.liveRegion.remove(); },
      }, f.init = function () { f.params.loop && f.createLoop(), f.updateContainerSize(), f.updateSlidesSize(), f.updatePagination(), f.params.scrollbar && f.scrollbar && f.scrollbar.set(), f.params.effect !== 'slide' && f.effects[f.params.effect] && (f.params.loop || f.updateProgress(), f.effects[f.params.effect].setTranslate()), f.params.loop ? f.slideTo(f.params.initialSlide + f.loopedSlides, 0, f.params.runCallbacksOnInit) : (f.slideTo(f.params.initialSlide, 0, f.params.runCallbacksOnInit), f.params.initialSlide === 0 && (f.parallax && f.params.parallax && f.parallax.setTranslate(), f.lazy && f.params.lazyLoading && f.lazy.load())), f.attachEvents(), f.params.observer && f.support.observer && f.initObservers(), f.params.preloadImages && !f.params.lazyLoading && f.preloadImages(), f.params.autoplay && f.startAutoplay(), f.params.keyboardControl && f.enableKeyboardControl && f.enableKeyboardControl(), f.params.mousewheelControl && f.enableMousewheelControl && f.enableMousewheelControl(), f.params.hashnav && f.hashnav && f.hashnav.init(), f.params.a11y && f.a11y && f.a11y.init(), f.emit('onInit', f); }, f.destroy = function (e) { f.detachEvents(), f.disconnectObservers(), f.params.keyboardControl && f.disableKeyboardControl && f.disableKeyboardControl(), f.params.mousewheelControl && f.disableMousewheelControl && f.disableMousewheelControl(), f.params.a11y && f.a11y && f.a11y.destroy(), f.emit('onDestroy'), e !== !1 && (f = null); }, f.init(), f;
    }
  }, Swiper.prototype = {
    isSafari: (function () { const e = navigator.userAgent.toLowerCase(); return e.indexOf('safari') >= 0 && e.indexOf('chrome') < 0 && e.indexOf('android') < 0; }()),
    isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),
    isArray(e) { return Object.prototype.toString.apply(e) === '[object Array]'; },
    browser: { ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled, ieTouch: window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1 || window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1 },
    device: (function () { const e = navigator.userAgent; const t = e.match(/(Android);?[\s\/]+([\d.]+)?/); const a = e.match(/(iPad).*OS\s([\d_]+)/); const r = (e.match(/(iPod)(.*OS\s([\d_]+))?/), !a && e.match(/(iPhone\sOS)\s([\d_]+)/)); return { ios: a || r || a, android: t }; }()),
    support: {
      touch: window.Modernizr && Modernizr.touch === !0 || (function () { return !!('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch); }()), transforms3d: window.Modernizr && Modernizr.csstransforms3d === !0 || (function () { const e = document.createElement('div').style; return 'webkitPerspective' in e || 'MozPerspective' in e || 'OPerspective' in e || 'MsPerspective' in e || 'perspective' in e; }()), flexbox: (function () { for (let e = document.createElement('div').style, t = 'alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient'.split(' '), a = 0; a < t.length; a++) if (t[a] in e) return !0; }()), observer: (function () { return 'MutationObserver' in window || 'WebkitMutationObserver' in window; }()),
    },
    plugins: {},
  }; for (var t = (function () {
      const e = function (e) { const t = this; let a = 0; for (a = 0; a < e.length; a++)t[a] = e[a]; return t.length = e.length, this; }; const t = function (t, a) { const r = []; let i = 0; if (t && !a && t instanceof e) return t; if (t) if (typeof t === 'string') { let s; let n; const o = t.trim(); if (o.indexOf('<') >= 0 && o.indexOf('>') >= 0) { let l = 'div'; for (o.indexOf('<li') === 0 && (l = 'ul'), o.indexOf('<tr') === 0 && (l = 'tbody'), (o.indexOf('<td') === 0 || o.indexOf('<th') === 0) && (l = 'tr'), o.indexOf('<tbody') === 0 && (l = 'table'), o.indexOf('<option') === 0 && (l = 'select'), n = document.createElement(l), n.innerHTML = t, i = 0; i < n.childNodes.length; i++)r.push(n.childNodes[i]); } else for (s = a || t[0] !== '#' || t.match(/[ .<>:~]/) ? (a || document).querySelectorAll(t) : [document.getElementById(t.split('#')[1])], i = 0; i < s.length; i++)s[i] && r.push(s[i]); } else if (t.nodeType || t === window || t === document)r.push(t); else if (t.length > 0 && t[0].nodeType) for (i = 0; i < t.length; i++)r.push(t[i]); return new e(r); }; return e.prototype = {
        addClass(e) { if (typeof e === 'undefined') return this; for (let t = e.split(' '), a = 0; a < t.length; a++) for (let r = 0; r < this.length; r++) this[r].classList.add(t[a]); return this; }, removeClass(e) { for (let t = e.split(' '), a = 0; a < t.length; a++) for (let r = 0; r < this.length; r++) this[r].classList.remove(t[a]); return this; }, hasClass(e) { return this[0] ? this[0].classList.contains(e) : !1; }, toggleClass(e) { for (let t = e.split(' '), a = 0; a < t.length; a++) for (let r = 0; r < this.length; r++) this[r].classList.toggle(t[a]); return this; }, attr(e, t) { if (arguments.length === 1 && typeof e === 'string') return this[0] ? this[0].getAttribute(e) : void 0; for (let a = 0; a < this.length; a++) if (arguments.length === 2) this[a].setAttribute(e, t); else for (const r in e) this[a][r] = e[r], this[a].setAttribute(r, e[r]); return this; }, removeAttr(e) { for (let t = 0; t < this.length; t++) this[t].removeAttribute(e); }, data(e, t) { if (typeof t === 'undefined') { if (this[0]) { const a = this[0].getAttribute(`data-${e}`); return a || (this[0].dom7ElementDataStorage && e in this[0].dom7ElementDataStorage ? this[0].dom7ElementDataStorage[e] : void 0); } return void 0; } for (let r = 0; r < this.length; r++) { const i = this[r]; i.dom7ElementDataStorage || (i.dom7ElementDataStorage = {}), i.dom7ElementDataStorage[e] = t; } return this; }, transform(e) { for (let t = 0; t < this.length; t++) { const a = this[t].style; a.webkitTransform = a.MsTransform = a.msTransform = a.MozTransform = a.OTransform = a.transform = e; } return this; }, transition(e) { typeof e !== 'string' && (e += 'ms'); for (let t = 0; t < this.length; t++) { const a = this[t].style; a.webkitTransitionDuration = a.MsTransitionDuration = a.msTransitionDuration = a.MozTransitionDuration = a.OTransitionDuration = a.transitionDuration = e; } return this; }, on(e, a, r, i) { function s(e) { const i = e.target; if (t(i).is(a))r.call(i, e); else for (let s = t(i).parents(), n = 0; n < s.length; n++)t(s[n]).is(a) && r.call(s[n], e); } let n; let o; const l = e.split(' '); for (n = 0; n < this.length; n++) if (typeof a === 'function' || a === !1) for (typeof a === 'function' && (r = arguments[1], i = arguments[2] || !1), o = 0; o < l.length; o++) this[n].addEventListener(l[o], r, i); else for (o = 0; o < l.length; o++) this[n].dom7LiveListeners || (this[n].dom7LiveListeners = []), this[n].dom7LiveListeners.push({ listener: r, liveListener: s }), this[n].addEventListener(l[o], s, i); return this; }, off(e, t, a, r) { for (let i = e.split(' '), s = 0; s < i.length; s++) for (let n = 0; n < this.length; n++) if (typeof t === 'function' || t === !1) typeof t === 'function' && (a = arguments[1], r = arguments[2] || !1), this[n].removeEventListener(i[s], a, r); else if (this[n].dom7LiveListeners) for (let o = 0; o < this[n].dom7LiveListeners.length; o++) this[n].dom7LiveListeners[o].listener === a && this[n].removeEventListener(i[s], this[n].dom7LiveListeners[o].liveListener, r); return this; }, once(e, t, a, r) { function i(n) { a(n), s.off(e, t, i, r); } var s = this; typeof t === 'function' && (t = !1, a = arguments[1], r = arguments[2]), s.on(e, t, i, r); }, trigger(e, t) { for (let a = 0; a < this.length; a++) { var r; try { r = new CustomEvent(e, { detail: t, bubbles: !0, cancelable: !0 }); } catch (i) { r = document.createEvent('Event'), r.initEvent(e, !0, !0), r.detail = t; } this[a].dispatchEvent(r); } return this; }, transitionEnd(e) { function t(s) { if (s.target === this) for (e.call(this, s), a = 0; a < r.length; a++)i.off(r[a], t); } let a; var r = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd']; var i = this; if (e) for (a = 0; a < r.length; a++)i.on(r[a], t); return this; }, width() { return this[0] === window ? window.innerWidth : this.length > 0 ? parseFloat(this.css('width')) : null; }, outerWidth(e) { return this.length > 0 ? e ? this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left')) : this[0].offsetWidth : null; }, height() { return this[0] === window ? window.innerHeight : this.length > 0 ? parseFloat(this.css('height')) : null; }, outerHeight(e) { return this.length > 0 ? e ? this[0].offsetHeight + parseFloat(this.css('margin-top')) + parseFloat(this.css('margin-bottom')) : this[0].offsetHeight : null; }, offset() { if (this.length > 0) { const e = this[0]; const t = e.getBoundingClientRect(); const a = document.body; const r = e.clientTop || a.clientTop || 0; const i = e.clientLeft || a.clientLeft || 0; const s = window.pageYOffset || e.scrollTop; const n = window.pageXOffset || e.scrollLeft; return { top: t.top + s - r, left: t.left + n - i }; } return null; }, css(e, t) { let a; if (arguments.length === 1) { if (typeof e !== 'string') { for (a = 0; a < this.length; a++) for (const r in e) this[a].style[r] = e[r]; return this; } if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(e); } if (arguments.length === 2 && typeof e === 'string') { for (a = 0; a < this.length; a++) this[a].style[e] = t; return this; } return this; }, each(e) { for (let t = 0; t < this.length; t++)e.call(this[t], t, this[t]); return this; }, html(e) { if (typeof e === 'undefined') return this[0] ? this[0].innerHTML : void 0; for (let t = 0; t < this.length; t++) this[t].innerHTML = e; return this; }, is(a) { if (!this[0]) return !1; let r; let i; if (typeof a === 'string') { const s = this[0]; if (s === document) return a === document; if (s === window) return a === window; if (s.matches) return s.matches(a); if (s.webkitMatchesSelector) return s.webkitMatchesSelector(a); if (s.mozMatchesSelector) return s.mozMatchesSelector(a); if (s.msMatchesSelector) return s.msMatchesSelector(a); for (r = t(a), i = 0; i < r.length; i++) if (r[i] === this[0]) return !0; return !1; } if (a === document) return this[0] === document; if (a === window) return this[0] === window; if (a.nodeType || a instanceof e) { for (r = a.nodeType ? [a] : a, i = 0; i < r.length; i++) if (r[i] === this[0]) return !0; return !1; } return !1; }, index() { if (this[0]) { for (var e = this[0], t = 0; (e = e.previousSibling) !== null;)e.nodeType === 1 && t++; return t; } return void 0; }, eq(t) { if (typeof t === 'undefined') return this; let a; const r = this.length; return t > r - 1 ? new e([]) : t < 0 ? (a = r + t, new e(a < 0 ? [] : [this[a]])) : new e([this[t]]); }, append(t) { let a; let r; for (a = 0; a < this.length; a++) if (typeof t === 'string') { const i = document.createElement('div'); for (i.innerHTML = t; i.firstChild;) this[a].appendChild(i.firstChild); } else if (t instanceof e) for (r = 0; r < t.length; r++) this[a].appendChild(t[r]); else this[a].appendChild(t); return this; }, prepend(t) { let a; let r; for (a = 0; a < this.length; a++) if (typeof t === 'string') { const i = document.createElement('div'); for (i.innerHTML = t, r = i.childNodes.length - 1; r >= 0; r--) this[a].insertBefore(i.childNodes[r], this[a].childNodes[0]); } else if (t instanceof e) for (r = 0; r < t.length; r++) this[a].insertBefore(t[r], this[a].childNodes[0]); else this[a].insertBefore(t, this[a].childNodes[0]); return this; }, insertBefore(e) { for (let a = t(e), r = 0; r < this.length; r++) if (a.length === 1)a[0].parentNode.insertBefore(this[r], a[0]); else if (a.length > 1) for (let i = 0; i < a.length; i++)a[i].parentNode.insertBefore(this[r].cloneNode(!0), a[i]); }, insertAfter(e) { for (let a = t(e), r = 0; r < this.length; r++) if (a.length === 1)a[0].parentNode.insertBefore(this[r], a[0].nextSibling); else if (a.length > 1) for (let i = 0; i < a.length; i++)a[i].parentNode.insertBefore(this[r].cloneNode(!0), a[i].nextSibling); }, next(a) { return new e(this.length > 0 ? a ? this[0].nextElementSibling && t(this[0].nextElementSibling).is(a) ? [this[0].nextElementSibling] : [] : this[0].nextElementSibling ? [this[0].nextElementSibling] : [] : []); }, nextAll(a) { const r = []; let i = this[0]; if (!i) return new e([]); for (;i.nextElementSibling;) { const s = i.nextElementSibling; a ? t(s).is(a) && r.push(s) : r.push(s), i = s; } return new e(r); }, prev(a) { return new e(this.length > 0 ? a ? this[0].previousElementSibling && t(this[0].previousElementSibling).is(a) ? [this[0].previousElementSibling] : [] : this[0].previousElementSibling ? [this[0].previousElementSibling] : [] : []); }, prevAll(a) { const r = []; let i = this[0]; if (!i) return new e([]); for (;i.previousElementSibling;) { const s = i.previousElementSibling; a ? t(s).is(a) && r.push(s) : r.push(s), i = s; } return new e(r); }, parent(e) { for (var a = [], r = 0; r < this.length; r++)e ? t(this[r].parentNode).is(e) && a.push(this[r].parentNode) : a.push(this[r].parentNode); return t(t.unique(a)); }, parents(e) { for (var a = [], r = 0; r < this.length; r++) for (let i = this[r].parentNode; i;)e ? t(i).is(e) && a.push(i) : a.push(i), i = i.parentNode; return t(t.unique(a)); }, find(t) { for (var a = [], r = 0; r < this.length; r++) for (let i = this[r].querySelectorAll(t), s = 0; s < i.length; s++)a.push(i[s]); return new e(a); }, children(a) { for (var r = [], i = 0; i < this.length; i++) for (let s = this[i].childNodes, n = 0; n < s.length; n++)a ? s[n].nodeType === 1 && t(s[n]).is(a) && r.push(s[n]) : s[n].nodeType === 1 && r.push(s[n]); return new e(t.unique(r)); }, remove() { for (let e = 0; e < this.length; e++) this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this; }, add() { let e; let a; const r = this; for (e = 0; e < arguments.length; e++) { const i = t(arguments[e]); for (a = 0; a < i.length; a++)r[r.length] = i[a], r.length++; } return r; },
      }, t.fn = e.prototype, t.unique = function (e) { for (var t = [], a = 0; a < e.length; a++)t.indexOf(e[a]) === -1 && t.push(e[a]); return t; }, t;
    }()), a = ['jQuery', 'Zepto', 'Dom7'], r = 0; r < a.length; r++)window[a[r]] && e(window[a[r]]); let i; i = typeof t === 'undefined' ? window.Dom7 || window.Zepto || window.jQuery : t, i && ('transitionEnd' in i.fn || (i.fn.transitionEnd = function (e) { function t(s) { if (s.target === this) for (e.call(this, s), a = 0; a < r.length; a++)i.off(r[a], t); } let a; var r = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd']; var i = this; if (e) for (a = 0; a < r.length; a++)i.on(r[a], t); return this; }), 'transform' in i.fn || (i.fn.transform = function (e) { for (let t = 0; t < this.length; t++) { const a = this[t].style; a.webkitTransform = a.MsTransform = a.msTransform = a.MozTransform = a.OTransform = a.transform = e; } return this; }), 'transition' in i.fn || (i.fn.transition = function (e) { typeof e !== 'string' && (e += 'ms'); for (let t = 0; t < this.length; t++) { const a = this[t].style; a.webkitTransitionDuration = a.MsTransitionDuration = a.msTransitionDuration = a.MozTransitionDuration = a.OTransitionDuration = a.transitionDuration = e; } return this; }));
}()), typeof module !== 'undefined' ? module.exports = Swiper : typeof define === 'function' && define.amd && define([], () => {
  'use strict';

  return Swiper;
});
// # sourceMappingURL=maps/swiper.min.js.map
